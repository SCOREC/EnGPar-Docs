% small.tex
\documentclass{beamer}
\usepackage[orientation=landscape, size = a0, scale=1.4]{beamerposter}
\usepackage[relative,overlay]{textpos}
\usetheme{Boadilla}
\usepackage{graphicx}
\usepackage{wrapfig}
%algorithms and pseudo code
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{numprint}
\usepackage{subcaption}
\usepackage{media9}
\usepackage{bibentry}
\usepackage[justification=centering]{caption}
\usepackage{pagecolor}
\usepackage{background}
\usepackage{blindtext}
\usepackage{xcolor}
\usepackage{enumitem}
\setlist[itemize,1]{label=\textbullet}
\setlist[itemize,2]{label=*}

%For example blocks
\setbeamercolor{block title example}{fg=red,bg=orange}
\setbeamercolor{block body example}{fg=cyan,bg=yellow}

\nobibliography*

%\setbeamertemplate{bibliography item}[text]
%\setbeamertemplate{author in head/foot}{\insertshortauthor}
%\setbeamertemplate{navigation symbols}{}

\newcommand{\lenitem}[2][.6\linewidth]{\parbox[t]{#1}{\strut #2\strut}}

\setbeamercolor{background canvas}{bg=cyan!50}

\begin{document}
\font\titlefont=cmr12 at 80pt
\title[Load Balancing of Unstructured Meshes]
{\titlefont
  Dynamic Load Balancing of \\[0.3cm]Massively Parallel Unstructured Meshes
}
\font\authorfont=cmr12 at 40pt
\author[G. Diamond]{\authorfont
  Gerrett Diamond, Cameron W. Smith, Mark S. Shephard\\
  Rensselaer Polytechnic Institute, USA}
\date{}
\font\abstractfont=cmr12 at 40pt
\begin{textblock}{15.8}(0.05,0.1)
  \titlepage
  \begin{textblock}{14}(1,-0.2)
    \begin{block}{}
      \begin{center}
      \abstractfont
      Parallel applications with complicated data structures and communicative patterns require partitioning algorithms that optimize specific metrics. While most partitioning methods can create partitions of a decent quality, further optimizations can be made for applications using diffusive load balancing techniques. EnGPar complements existing multi-level and geometric partitioning methods that allows multi-criteria partition improvement. EnGPar utilizes a specialized multi-graph, called the N-graph, to represent relation based data and perform performant load balancing for a range of data formats.
              
      \end{center}
    \end{block}
  \end{textblock}
\end{textblock}

\begin{textblock}{15.6}(0.2,4)
  \begin{textblock}{5}(0,0)
    \begin{block}{EnGPar: Diffusive Graph Partitioning}
      The N-graph is defined as the following:
      \begin{itemize}
      \item A set of vertices $V$ representing the atomic units of work.
      \item If using the traditional graph mode:
        \begin{itemize}
        \item $N$ sets of edges $E_0,...,E_{n-1}$ for each type of relation.
        \item Each edge connects two vertices $u,v \in V$.
        \end{itemize}
      \item If using the hypergraph mode:
        \begin{itemize}
        \item $N$ sets of hyperedges $H_0,...,H_{n-1}$ for each type of relation.
        \item $N$ sets of pins $P_0,...,P_{n-1}$ corresponding to each set of hyperedges.
        \item Each pin in $P_i$ connects a vertex, $v \in V$, to a hyperedge $h \in H_i$.
        \end{itemize}
      \end{itemize}

      Advantages
      \begin{itemize}
      \item Multiple edge types allow for partitioning of multiple criteria simultaneously.
      \item Easy to use with diffusive procedures - compliments other partition methods via incremental refinements.
      \end{itemize}
      
      Diffusive Approach
      \begin{itemize}
      \item Iteratively migrate small sets of vertices to (1) reduce the peak imbalance and (2) reduce the number of (hyper)edges that are cut between part boundaries.
      \end{itemize}
      
      Diffusive Iteration Stages
      \begin{itemize}
      \item Weight Computation $-$ compute weights and exchange with peers.
      \item Targeting $-$ determined how much weight each peer can accept.
      \item Selection $-$ select vertices for migration.
      \item Migration $-$ move elements to peers.
      \end{itemize}
    \end{block}
    \begin{block}{CODES: Discrete Event Simulations}
      CODES is an application that simulates running an MPI application on a simulated hardware architecture. The application uses an trace of a previous run of the application and then maps it to the simulated architecture. This results in two relation based structures:
      \begin{itemize}
      \item The architecture graph consisting of compute nodes and network nodes.
      \item The relation between MPI processes from the application trace.
      \end{itemize}
      The N-graph is constructed based on the application trace where:
      \begin{itemize}
        \item vertices are created from the MPI processes in the trace.
        \item edges are created between two vertices that have an event between them.
      \end{itemize}
      %Add further ideas to also convert the network graph
    \end{block}
  \end{textblock}
  \begin{textblock}{5}(5.3,0)
    \begin{block}{Finite Element Analysis: Unstructured Meshes}
      %FEM description
      Applications using unstructured meshes exhibit several partitioning problems including
      \begin{itemize}
      \item Multiple coupled entity dimensions to partition.
      \item Complex communication patterns to be minimized.
      \end{itemize}
      Standard linear finite element analysis problems require that mesh vertices be balanced as well as mesh elements to get the best performance.\\
      %N-graph construction
      To properly balance, we construct the N-graph where:
      \begin{itemize}
      \item mesh elements are represented as graph vertices,
      \item mesh vertices are represented by hyperedges, and
      \item pins are created from each graph vertex to hyperedge where the mesh element is bounded by the mesh vertex.
      \end{itemize}
      See Figure (Add mesh$->$ngraph image).

      %Add higher order notes if there is room
    \end{block}
    \begin{block}{Strong Scaling of Unstructured Mesh}
      %Discuss testing
      Tests were run on a one billion element mesh created and partitioned using:
      \begin{itemize}
      \item Global ParMETIS part k-way to 8Ki($8*2^{10}$) parts and
      \item Local ParMETIS part k-way from 8Ki to 128Ki, 256Ki, and 512Ki parts.
      \end{itemize}

      %Add results and images/graphs
    \end{block}
  \end{textblock}
  \begin{textblock}{5}(10.6,0)
    \begin{block}{Overset Grids}
      Some unstructured mesh applications are accompanied with an overset grid.
      %More info about the overset grid applications

      %List assumptions
      %example image of the overset grid + mesh
      
      %Describe the construction of the N-graph
      To construct the N-graph for these applications we:
      \begin{itemize}
      \item construct the vertices and hyperedges on the unstructured mesh any way for the application,
      \item add vertices for each element in the overset grid.
      \item add a second edge type that connects the graph vertices from the unstructured mesh to the graph vertices from the grid when the elements overlap.
      \end{itemize}

      %Add picture showing the conversion
      
    \end{block}
    
    \begin{block}{FUN3D: Fluid dynamics simulations}
      FUN3D is a finite element application that exhibits several partitioning problems beyond those found in standard finite element codes such as:
      \begin{itemize}
      \item The unstructured mesh is partitioned by mesh vertices.
      \item The simulation requires a ghost layer at part boundaries of neighboring elements.
      \item Supports using an overset grid to interact with other simulations.
      \end{itemize}

      %Either describe parma and how it cant successfully balance this or generally discuss how partition methods fail
      Traditional partitioning methods have trouble balancing these metrics simultaneously and the vertex-based partition makes it difficult to use element-based tools such as ParMA (REFERENCE).

      %add picture example of a FUN3D problem if possible

      %Discuss construction of N-graph
      For EnGPar, the construction of the graph on the mesh is as follows:
      \begin{itemize}
      \item create graph vertices from the mesh vertices
      \item create hyperedges for each mesh element
      \item create a pin for each mesh element surrounding the mesh vertex.
      \end{itemize}

      The ghost layer can be treated by accounting for the weight of the ghosted vertices in the diffusive iterations (supply reference for previous work on ghost balancing). Furthermore the overset grid can be accounted for in a similar way as listed above.

      
    \end{block}
  \end{textblock}
\end{textblock}

\end{document}
