% small.tex
\documentclass{beamer}
\usetheme{Madrid}
%Berlin(bottom bar) / Frankfurt (more room) / Copenhagen (more room, bottom bar|split)
\usepackage[orientation=landscape, size = a0, scale=1.4]{beamerposter}
\usepackage[relative,overlay]{textpos}
\usepackage{graphicx}
\usepackage{wrapfig}
%algorithms and pseudo code
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{numprint}
\usepackage{subcaption}
\usepackage{media9}
\usepackage{bibentry}
\usepackage[justification=centering]{caption}
\usepackage{pagecolor}
\usepackage{background}
\usepackage{blindtext}
\usepackage{xcolor}
\usepackage{enumitem}
\setlist[itemize,1]{label=\textbullet}
\setlist[itemize,2]{label=*}
\usepackage{caption}
\captionsetup[figure]{labelformat=empty}

\nobibliography*

%\setbeamertemplate{bibliography item}[text]
%\setbeamertemplate{author in head/foot}{\insertshortauthor}
%\setbeamertemplate{navigation symbols}{}

\newcommand{\lenitem}[2][.6\linewidth]{\parbox[t]{#1}{\strut #2\strut}}

\setbeamercolor{background canvas}{bg=cyan!50}
\setbeamercolor{block title}{bg=blue!75}
\setbeamercolor{block body}{bg=white,fg=black}
\begin{document}
\font\titlefont=cmr12 at 80pt
\title[]
{\titlefont
  Dynamic Load Balancing of \\[0.3cm]Massively Parallel Unstructured Meshes
}
\font\authorfont=cmr12 at 40pt
\author[G. Diamond]{\authorfont
  Gerrett Diamond, Cameron W. Smith, Mark S. Shephard\\
  Rensselaer Polytechnic Institute, USA}
\date{}
\font\abstractfont=cmr12 at 40pt
\begin{textblock}{15.8}(0,0)
  \titlepage
  \begin{textblock}{14}(1,-0.5)
    \setbeamercolor{block body}{bg=blue!75,fg=white}
    \begin{block}{}
      \begin{textblock}{13.5}(0.25,0.1)
      \begin{center}
        \abstractfont
        
      Parallel applications with complicated data structures and communicative patterns
      require partitioning algorithms that optimize specific metrics. While most
      partitioning methods can create partitions of a decent quality, further
      optimizations can be made for applications using diffusive load balancing techniques.
      EnGPar complements existing multi-level and geometric partitioning methods that allows
      multi-criteria partition improvement. EnGPar utilizes a specialized multi-graph, called
      the N-graph, to represent relation based data in order to perform load balancing for a
      range of data formats.
      \end{center}
      \end{textblock}
      \vspace{6.5cm}
    \end{block}
  \end{textblock}
\end{textblock}

\begin{textblock}{15.6}(0.1,3.75)
  \begin{textblock}{5}(0,0)
    \begin{block}{\centering Partitioning of Relation-based Data}
       
    \end{block}
    \begin{block}{\centering EnGPar: Diffusive Graph Partitioning}
      The N-graph is defined as the following:
      \begin{itemize}
      \item A set of vertices $V$ representing the atomic units of work.
      \item If using the traditional graph mode:
        \begin{itemize}
        \item $N$ sets of edges $E_0,...,E_{n-1}$ for each type of relation.
        \item Each edge connects two vertices $u,v \in V$.
        \end{itemize}
      \item If using the hypergraph mode:
        \begin{itemize}
        \item $N$ sets of hyperedges $H_0,...,H_{n-1}$ for each type of relation.
        \item $N$ sets of pins $P_0,...,P_{n-1}$ corresponding to each set of hyperedges.
        \item Each pin in $P_i$ connects a vertex, $v \in V$, to a hyperedge $h \in H_i$.
        \end{itemize}
      \end{itemize}

      Advantages
      \begin{itemize}
      \item Multiple edge types allow for partitioning of multiple criteria simultaneously.
      \item Easy to use with diffusive procedures - compliments other partition methods via incremental refinements.
      \end{itemize}
      
      Diffusive Approach
      \begin{itemize}
      \item Iteratively migrate small sets of vertices to (1) reduce the peak imbalance and (2) reduce the number of (hyper)edges that are cut between part boundaries.
      \end{itemize}
    \end{block}
    \begin{block}{\centering CODES: Discrete Event Simulations}
      CODES is an application that simulates running an MPI application on a simulated
      hardware architecture. The application uses an trace of a previous run of the
      application and then maps it to the simulated architecture. This results in two
      relation based structures:
      \begin{itemize}
      \item The architecture graph consisting of compute nodes and network nodes.
      \item The relation between MPI processes from the application trace.
      \end{itemize}
      The N-graph is constructed based on the application trace where:
      \begin{itemize}
        \item vertices are created from the MPI processes in the trace.
        \item edges are created between two vertices that have an event between them.
      \end{itemize}
      %Add further ideas to also convert the network graph
    \end{block}
  \end{textblock}
  \begin{textblock}{5}(5.3,0)
    \begin{block}{\centering Finite Element Analysis: Unstructured Meshes}
      %FEM description
      Applications using unstructured meshes exhibit several partitioning problems including
      \begin{itemize}
      \item Multiple coupled entity dimensions to partition.
      \item Complex communication patterns to be minimized.
      \end{itemize}
      Standard linear finite element analysis problems require that mesh vertices be balanced as well as mesh elements to get the best performance.\\
      %N-graph construction
      To properly balance, we construct the N-graph where:
      \begin{itemize}
      \item mesh elements are represented as graph vertices,
      \item mesh vertices are represented by hyperedges, and
      \item pins are created from each graph vertex to hyperedge where the mesh element is bounded by the mesh vertex.
      \end{itemize}
      \begin{figure}
        \centering
        \includegraphics[width=.7\textwidth]{../figures/exampleMesh2Graph_backgroundless.png}
        \caption{Conversion from mesh (a) to N-graph (b),(c).}
      \end{figure}
     %Add higher order notes if there is room
    \end{block}
    \begin{block}{\centering Strong Scaling of Unstructured Mesh}
      %Discuss testing
      Tests were run on a one billion element mesh created and partitioned using:
      \begin{itemize}
      \item Global ParMETIS part k-way to 8Ki($8*2^{10}$) parts and
      \item Local ParMETIS part k-way from 8Ki to 128Ki, 256Ki, and 512Ki parts.
      \end{itemize}
      \begin{textblock}{2.3}(0,0.1)
        The initial partitions stats are: \\[1cm]

        Computing the 512Ki partition from 8Ki parts took 16 seconds, followed by a migration that took 131 seconds.
        
      \end{textblock}
      \begin{textblock}{2.5}(2.3,0)
      \begin{table}[!h]
        \centering
        \begin{tabular}{||c|c|c|c||}
          \hline
          Number of Parts &128Ki&256Ki&512Ki \\
          \hline
          Elements per part & 9,836 & 4,918&2,459  \\
          \hline
          Vertex imbalance & 1.13 & 1.18 & 1.53 \\
          \hline
          Element imbalance & 1.02& 1.02& 1.02\\
          \hline
        \end{tabular}
      \end{table}
      \end{textblock}
      \vspace{10cm}

      Running EnGPar on the three meshes results in:
      \begin{itemize}
      \item reducing element imbalance to 5\%
      \item reducing vertex imbalance to 5\% except for the 512Ki case which is reduced to 12\% imbalance.
      \item each run took less than 10 seconds to compute and migrate the data.
      \end{itemize}
      
      %Add results and images/graphs
      
    \end{block}
  \end{textblock}
  \begin{textblock}{5}(10.6,0)
    \begin{block}{\centering Overset Grids}
      Some unstructured mesh applications are accompanied with an overset grid.
      \begin{textblock}{2.7}(0,0.1)
        %More info about the overset grid applications
        These simulations add additional partitioning challenges such as:
        \begin{itemize}
        \item computational coupling between the meshes
        \item additional communication sources
        \item More...
        \end{itemize}

        %List assumptions?
        

      \end{textblock}
      \begin{textblock}{2.5}(2.5,0)
        %example image of the overset grid + mesh
        \begin{figure}
          \centering
          \includegraphics[height=.6\textwidth]{../figures/overset_grid.jpg}
          \caption{An unstructured mesh (in red) with \\an overset grid (in black).}
        \end{figure}
      \end{textblock}
      \vspace{14cm}

      
      %Describe the construction of the N-graph
      To construct the N-graph for these applications we:
      \begin{itemize}
      \item construct the vertices and hyperedges on the unstructured mesh any way for the application,
      \item add vertices for each element in the overset grid.
      \item add a second edge type that connects the graph vertices from the unstructured mesh to the graph vertices from the grid where the elements overlap.
      \end{itemize}

      %Add picture showing the conversion
      
    \end{block}
    
    \begin{block}{\centering FUN3D: Fluid dynamics simulations}
      FUN3D is a finite volume application that exhibits several partitioning problems beyond those found in standard finite element codes such as:
      \begin{itemize}
      \item The unstructured mesh is partitioned by mesh vertices.
      \item The simulation requires a ghost layer at part boundaries of neighboring elements.
      \item Supports using an overset grid to interact with other simulations.
      \end{itemize}

      %Either describe parma and how it cant successfully balance this or generally discuss how partition methods fail
      Traditional partitioning methods have trouble balancing these metrics simultaneously and the vertex-based partition makes it difficult to use element-based tools such as ParMA (REFERENCE).

      %add picture example of a FUN3D problem if possible

      %Discuss construction of N-graph
      For EnGPar, the construction of the graph on the mesh is as follows:
      \begin{itemize}
      \item create graph vertices from the mesh vertices
      \item create hyperedges for each mesh element
      \item create a pin for each mesh element surrounding the mesh vertex.
      \end{itemize}

      The ghost layer can be treated by accounting for the weight of the ghosted vertices in the diffusive iterations (supply reference for previous work on ghost balancing). Furthermore the overset grid can be accounted for in a similar way as listed above.

      
    \end{block}
  \end{textblock}
\end{textblock}

\end{document}
