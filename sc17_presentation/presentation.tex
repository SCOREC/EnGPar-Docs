% small.tex
\documentclass{beamer}
\usetheme{Boadilla}
\usepackage{graphicx}
\usepackage{wrapfig}
%algorithms and pseudo code
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{numprint}
\usepackage{subcaption}
\usepackage{media9}
\usepackage{bibentry}
\nobibliography*

\setbeamertemplate{bibliography item}[text]
\setbeamertemplate{author in head/foot}{\insertshortauthor}
\setbeamertemplate{navigation symbols}{}

\newcommand{\lenitem}[2][.6\linewidth]{\parbox[t]{#1}{\strut #2\strut}}
\newcommand{\outline}{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}

\begin{document}

\title[Unstructured Mesh Workflows]
{
Dynamic Load Balancing of Massively Parallel Unstructured Meshes
}
\author{Gerrett Diamond, Cameron W. Smith, Mark S. Shephard}
%\email{diamog@rpi.edu}
%\author[smithc11@rpi.edu]{Cameron W. Smith\\
%  \smallskip
%  Committee:\\
%  Mark Shephard\\
%  Max Bloomfield, Christopher Carothers, Barbara Cutler, Onkar Sahni
%}

\institute[SCOREC]{
Scientific Computation Research Center \\
Rensselaer Polytechnic Institute
}

\date{November 13, 2017}

%----------- titlepage ----------------------------------------------%
\begin{frame}[plain]
  \titlepage
\end{frame}

%----------- outline ----------------------------------------------%
\begin{frame}
  \frametitle{Outline}
  \tableofcontents
\end{frame}

%----------------------------------------------------------------------%
%----------- Section --------------------------------------------------%
%----------------------------------------------------------------------%
\section{Partitioning and Load Balancing}
\begin{frame}
  \frametitle{Movtivation \& definitions}
  Many evolving distributed simulations have: \\
  \begin{itemize}
    \item Complex relational structures.
    \item Irregular forms of computational and communication costs.
    \item Evolving imbalance of work. %Define Imbalance
    \item Multiple criterias that need balancing simulataneously.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Common Methods for Partitioning}
  \begin{itemize}
  \item Multilevel Graph Methods %Discuss poor scaling
    \begin{itemize}
    \item ParMETIS
    \item Zoltan
    \end{itemize}
  \item Geometric Methods %Require coordinates
    \begin{itemize}
    \item Recursive Coordinate Bisection (RCB)
    \item Recursive Inertial Bisection (RIB)
    \item Multi-Jagged
    \end{itemize}
  \item Diffusive Methods %Improve a partition efficiently
    \begin{itemize}
    \item Label Propogation
%    \item ParMA
%    \item EnGPar
    \end{itemize}
  \end{itemize}
\end{frame}

%Maybe one more slide to discuss in more detail why we need diffusive load balancing

\section{EnGPar - a graph based diffusive load balancer}

\begin{frame}
  \frametitle{What is EnGPar?}
  \begin{itemize}
  \item A partitioning tool to complement existing multi-level and geometric methods.
  \item Provides a diffusive load balancing algorithm for partition improvement and supports multi-criteria partitioning.
  \item Utilizes a specialized multigraph structure to represent relation based data.
  \item Implemented to support efficient data parallel operations on accelerators and vector units in many core processors.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Software}
  EnGPar's source can be found at \url{https://github.com/SCOREC/EnGPar}.
  \begin{itemize}
  \item Written in C++ using MPI.
  \item Utilizes CMake for building.
  \item Depends on a SCOREC developed communication library, PCU.
  \item Implementing accelerator support using Kokkos.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{N-graph}
  %EnGPar utilizes an expanded multigraph structure called the N-graph.\\
  %THIS IS TOO MUCH TEXT PROBABLY...
  The N-graph is a multigraph with two modes of operation: traditional or hypergraph.\\
  \smallskip
  The N-graph is defined as the following:
  \begin{itemize}
  \item A set of vertices $V$ representing the atomic units of work.
  \item If using the traditional graph mode:
    \begin{itemize}
    \item $N$ sets of edges $E_0,...,E_{n-1}$ for each type of relation.
    \item Each edge connects two vertices $u,v \in V$.
    \end{itemize}
  \item If using the hypergraph mode:
    \begin{itemize}
    \item $N$ sets of hyperedges $H_0,...,H_{n-1}$ for each type of relation.
    \item $N$ sets of pins $P_0,...,P_{n-1}$ corresponding to each set of hyperedges.
    \item Each pin in $P_i$ connects a vertex, $v \in V$, to a hyperedge $h \in H_i$.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Mapping structures to the N-graph}
  %Before using EnGPar a simulation must first map its data to the N-graph
  To map to the N-graph simulations must:
  \begin{itemize}
  \item Define units of work as the vertices.
  \item Decide on the mode of edges to use.
  \item Create (hyper)edges between the vertices whose corresponding work relate to each other.
  \end{itemize}
  %Figure showing the conversion from mesh to N-graph
  \begin{figure}
    \centering
    \includegraphics[width=.9\textwidth,height = 1.75in]{figures/exampleMesh2Graph.png}
  \end{figure}
\end{frame}

\begin{frame}
  \frametitle{Diffusive Partitioning}
  \begin{algorithm}[H]
    \caption{Diffusive Load Balancing Framework}
    \label{alg:engpar}
    \small
    \begin{algorithmic}[1]
      \Procedure{Balance}{$ngraph$,$dimensions$}
      \ForAll{$d \in dimensions$}
      \While{imbalance of $d >$ tolerance}
      \Call{RunStep}{$ngraph$,$d$}
      \If{Balancing Stagnates}
      \State break
      \EndIf
      \EndWhile
      \EndFor
      \EndProcedure

      \Procedure{RunStep}{$ngraph$,$d$}
      \State $sides = makeSides(ngraph)$
      \State $weights = makeWeights(ngraph,sides,d)$
      \State $targets = makeTargets(ngraph,sides,weights)$
      \State $queue = makeIterationQueue(ngraph)$
      \State $plan = select(ngraph,targets,queue)$
      %\State $trim(ngraph,plan)$
      \State $ngraph.migrate(plan)$
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}
\end{frame}

%More slides to describe each step with some detail
\begin{frame}
  \frametitle{Neighbor Initialization}
  \begin{itemize}
  \item Sides
    \begin{itemize}
    \item Each part determines which parts are its neighbors.
    \item Determines a measurement of the area of the part boundary.
    \end{itemize}
  \item Weights
    \begin{itemize}
    \item Each part computes its weight of the current target dimension.
    \item This weight is shared with all of the part's neighbors(sides).
    \end{itemize}
  \item Targets
    \begin{itemize}
    \item Each part determines which part they will send weight to.
    \item Weight to send from part $i$ to part $j$ is $(w_i-w_j)*\dfrac{\text{size}(s_{ij})}{\text{size}(s)}$
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Building the Migration Plan}
  \begin{itemize}
  \item Selection
    \begin{itemize}
    \item Iterates over (hyper)edges that cross a part boundary.
    \item The vertices on part that are bounded by the (hyper)edge form a cavity.
    \item The cavity is chosen for migration if the (hyper)edge is on the boundary of a targeted part and the weight limit hasn't been exceeded.
    \end{itemize}
    %Replace trim with a figure
%  \item Trim %This may be cut for time/understanding sake
%    \begin{itemize}
%    \item In the case of multiple criteria, the migration plan created through selection may be reduced.
%    \item This reduction ensures that the weight being sent will not increase the previously balanced criteria.
%    \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Iteration Queue}
  %the edges on the boundary are ordered/not vertices
  In order to make well shaped parts and minimize part boundaries, the order that vertices are selected matters. \\
  \bigskip
  Ordering is computed based on distance from the center of the part. \\
  \bigskip
  This is done in two steps:
  \begin{itemize}
  \item A breadth-first traversal starting at the part boundary to determine the center of the part.
  \item A breadth-first traversal starting at the center to compute topological distance for each vertex on the part boundary.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Iteration Queue}
  
  In this case, distances are calculated separately and components are ordered based on shallowness.

\end{frame}


\section{Comparison to ParMA}

\begin{frame}
  \frametitle{Experiments}
  %Describe the mesh, system run on, initial partition etc.
  We compare EnGPar's performance to its predecessor ParMA, which is built to operate directly on unstructured meshes.\\
  \medskip
  Tests were run on a billion element mesh partitioned to 128Ki, 256Ki and 512Ki parts using ParMETIS. \\
  \medskip
  EnGPar and ParMA are used to balance the three partitions on the Mira BlueGene/Q system.
\end{frame}

\begin{frame}
  \frametitle{Problem Setup}
  ParMA and EnGPar are set to balance the mesh for a standard finite element analysis where:
  \begin{itemize}
  \item Scalability of matrix formation is sensitive to mesh element imbalance.
  \item Linear algebra routines are sensitive to the imbalance of degrees of freedom.
  \item For this we assume the degrees of freedom are associated with mesh vertices.
  \end{itemize}
  \bigskip
  To partition for this, both balance mesh vertices followed by elements with a target imbalance of 1.05. \\
  
\end{frame}

%More slides to go over the results in the paper
\begin{frame}
  \frametitle{Mesh Vertex Imbalance}
  %Figure showing the conversion from mesh to N-graph
  \begin{figure}
    \centering
    \includegraphics[width=.8\textwidth]{figures/vimb_v_cores.eps}
  \end{figure}  
\end{frame}

\begin{frame}
  \frametitle{Mesh Element Imbalance}
  %Figure showing the conversion from mesh to N-graph
  \begin{figure}
    \centering
    \includegraphics[width=.8\textwidth]{figures/eimb_v_cores.eps}
  \end{figure}  
\end{frame}

\begin{frame}
  \frametitle{RunTime Comparison}
  \begin{figure}
    \centering
    \includegraphics[width=.8\textwidth]{figures/time_v_cores.eps}
  \end{figure}
  
\end{frame}

\begin{frame}
  \frametitle{Future Work}
  Expanding the capabilities of EnGPar:
  \begin{itemize}
  \item Improve partitioning at very high part count.
  \item Improve performance of the balancing procedures using accelerators.
  \end{itemize}
  Applying EnGPar to other applications:
  \begin{itemize}
  \item CODES - a discrete event simulation for communication on supercomputer networks. \url{press3.mcs.anl.gov/codes/}
  \item FUN3D - a computational fluid dynamic simulation using a vertex-based partitioned mesh. \url{fun3d.larc.nasa.gov}
  \item PHASTA - massively parallel computational fluid dynamics. \url{github.com/PHASTA/phasta}
    %For future note: most glorious computational fluid dynamics that scales to the moon...

  \end{itemize}
\end{frame}
  
\end{document}
